{
  "id": "401465483996",
  "displayName": "Brett Wiltshire",
  "email": "brett@email.com", // tem quer ser único
  "password": "123456",
  "image": "http://4.bp.blogspot.com/_YA50adQ-7vQ/S1gfR_6ufpI/AAAAAAAAAAk/1ErJGgRWZDg/S45/brett.png"
}
{
  "id": "7706273476706534553",
  "title": "Latest updates, August 1st",
  "content": "The whole text for the blog post goes here in this key",
  "user_id": "401465483996", // esse é o id que referência usuário que é o autor do post
  "published": "2011-08-01T19:58:00.000Z",
  "updated": "2011-08-01T19:58:51.947Z",
}

Case 1 - Cultura
Assista ao Manifesto Stone 2017, pesquise bastante sobre história e nossa cultura e construa um case sobre:

Quais são os seus valores e como você se conecta com os valores da Stone?
Como a missão da Stone faz a diferença na sociedade brasileira?
Quais são os pros e contras de trabalhar na empresa?
Apresente o seu case da forma que achar melhor e se sentir mais confortável: slides, oralmente, vídeo, etc.

Case 2 - Técnico
Implementar uma aplicação client-side onde será encontrar todas as informações sobre as comics e characters da marvel;
Implementar uma aplicação server-side que conterá funções de autenticação, gerenciamentos de usuários e de comics/characters favoritos.
API
Utilizar a api de developer da marvel (https://developer.marvel.com/).
Navegação
Deve existir uma página de cadastro de usuário para a aplicação;
Ao cadastrar o usuário será possível realizar o login;
Ao logar na aplicação deverá ser possível realizar a alterações dos dados do usuário. ex: login, senha, etc...;
Ao logar na aplicação deverá ser possível realizar a busca de characters e comics da marvel e os favoritos do usuário;
Buscando por Comics: ao encontrar uma comic desejada deve ser possível favoritar e visualizar as informações da mesma e a exibição dos characteres presentes nela, sendo possível selecionar um character e visualizar as informações do mesmo;
Buscando por Characteres: ao encontrar um character desejado deve ser possível favoritar e visualizar as informações do mesmo e a exibição das comics onde ele participa, sendo possível selecionar uma comic e visualizar as informações da mesma;
Exibindo favoritos: deve existir páginas que exibe as comics favoritas e os characters favoritos do usuário, podendo exibir as informações dos mesmos.
Requisitos
Eu, como usuário, desejo me cadastrar na aplicação e efetuar login/logout;
Eu, como usuário, desejo editar minhas informações;
Eu, como usuário, desejo ver a listagem e detalhes das comics, podendo favoritar ou desfavoritar;
Eu, como usuário, desejo ver a listagem e detalhes dos characters, podendo favoritar ou desfavoritar;
Eu, como usuário, desejo ver a listagem e detalhes dos characters e comics favoritos.
Dicas e Sugestões
Client-Side
Não é obrigatório o uso de um framework ou lib, mas recomendamos a utilização do React;
É obrigatório o uso de rotas.
Server-Side
A linguagem do backend não é restrita e nem o uso de framework, mas recomendamos a utilização de Javascript;
Para melhorar segurança da aplicação sugerimos a utilização de JWT para a autenticação;
Sugerimos a utilização de um banco de dados relacional;
É obrigatório utilizar API com arquitetura REST.
Submissão
O desafio deve ser entregue pelo GitHub. As aplicações devem estar hospedadas (ex: GitHub Pages, Now, Netlify, Firebase, Heroku, etc) e suas URLs devem ser enviadas por email.
Critérios de Avaliação
O desafio será avaliado através de cinco critérios:
Entrega
O código possui algum controle de dependências?
O resultado final está completo para ser executado?
O resultado final atende ao que se propõe fazer?
O resultado final atende totalmente aos requisitos propostos?
O resultado final é visualmente elegante?
Boas Práticas
O código está de acordo com o guia de estilo da linguagem?
O código está bem estruturado?
O código está fluente na linguagem?
O código faz o uso correto de Design Patterns?
Documentação
O código foi entregue com um arquivo de README claro de como se guiar?
O código possui comentários pertinentes?
O código está em algum controle de versão?
Os commits são pequenos e consistentes?
As mensagens de commit são claras?
Código Limpo
O código possibilita expansão para novas funcionalidades?
O código é Don't Repeat Yourself?
O código é fácil de compreender?
Controle de Qualidade
O código possui configuração de lint?
O código possui testes unitários?
O código possui teste de cobertura?
O código está em Integração Contínua?
Material de Estudo
Boas Práticas na Stone
monica.menezes@fcamara.com.br 
https://pt.slideshare.net/FCamara_Consultoria/culture-code-60932552  joel 

##########################################
// router.put('/:id', async (req, res) => {
//   const { id } = req.params;
//   const { name, description, price } = req.body;
//   await Product.update(
//     { name, description, price },
//     {
//       where: { id },
//     }
//   );
//   res.status(200).json({ message: 'produto alterado com sucesso' });
// });

// router.delete('/:id', async (req, res) => {
//   const { id } = req.params;
//   await Product.destroy({
//     where: { id },
//   });

//   res.status(204).json({ message: 'Produto deletado com sucesso' });
// });

// router.get('search', async (req, res) => {
//   const { q } = req.query;

//   const user = await Users.findAll({
//     where: {
//       name: {
//         [Op.like]: `%${q}%`,
//       },
//     },
//   });
// });

// router.get('/:id', async (req, res) => {
//   const product = await Product.findByPk(id);
//   res.status(200).json(product);
// });

################################
A camada de controle
O controller recebe as requisições do cliente e então consulta o service enviando para o cliente aquilo que o service retornar, podendo ser uma mensagem de erro em caso de falha ou as informações requisitas em caso de sucesso. Em uma aplicação Node com Express, o controller vai ser a camada onde iremos definir nossos middlewares para rotas, geralmente em um escopo definido para um contexto bem específico.
Ao se comunicar com o service , o controller deve passar apenas as informações necessárias, sendo assim não é uma boa prática passar toda a request para o service , as informações devem ser extraídas e então apenas o que for necessário para determinada ação deve ser transferido.
Uma ótima analogia para o controller é que ele seria como um garçom em um restaurante.
O garçom não sabe como preparar os pratos e nem como recepcionar as pessoas na porta.
Ele apenas anota o pedido, sabe para que parte do restaurante levar o pedido e para qual mesa entregá-lo depois de pronto.
Quando você monta seu software em uma camada só, é como se o garçom fizesse todas as funções dentro do seu restaurante (recepcionar, anotar os pedidos, preparar os pratos etc.).

################
A camada de serviço
Até agora, temos dito que regras de negócio ficam no modelo. E isso é verdade em outros padrões arquiteturais.
Mas é comum que, à medida que projetos vão crescendo, os modelos vão ficando cada vez maiores e mais complexos, pois vão acumulando cada vez mais regras de negócio.
Por isso, é comum vermos uma nova camada sendo adicionada em projetos que exigem uma lógica de negócio um pouco mais complexa e, principalmente, em APIs.
Essa camada é chamada de service . Ela fica situada entre as camadas de controller e model e é responsável pela nossa lógica de negócio. O modelo, então, passa a ser responsável somente pelo acesso a dados.
Você pode ver isso de outra forma: para evitar que o modelo fique grande demais, ele é quebrado em duas outras camadas, cada uma com parte da responsabilidade.
Pense nessa camada como o chef da cozinha do nosso restaurante. Ele é quem sabe as receitas e delega as funções para os funcionários depois de receber o pedido do garçom.
O diagrama abaixo mostra um exemplo de como isso funcionaria em um cenário em que temos apenas uma API exposta a requisições.